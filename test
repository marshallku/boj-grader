#!/bin/bash

lang='cpp'
file=''
output=false

while [[ $# -gt 0 ]]; do
    case "$1" in
    -l | --lang)
        lang="$2"
        shift 2
        ;;
    -f | --file)
        file="$2"
        shift 2
        ;;
    -w | --write-output)
        output=true
        shift
        ;;
    *)
        echo "Unknown argument: $1"
        exit 1
        ;;
    esac
done

if [[ -n "$file" ]]; then
    extension="${file##*.}"

    case $extension in
    cpp)
        lang='cpp'
        ;;
    py)
        lang='python'
        ;;
    *)
        echo "Unsupported extension: $extension"
        echo 'Allowed extensions: cpp, py'
        exit 5
        ;;
    esac
else
    # Check language automatically with checking files
    python_file_exists=false
    cpp_file_exists=false

    if test -f 'solution.py'; then
        python_file_exists=true
        lang='python'
    fi

    if test -f 'solution.cpp'; then
        cpp_file_exists=true
        lang='cpp'
    fi

    if [ "$python_file_exists" == 'true' ] && [ "$cpp_file_exists" == 'true' ]; then
        source './src/utils/select.sh'
        select_message='Which language will you test?'
        options=('c++' 'python')
        select_options
        lang="${options[$selected]}"
    fi
fi

case $lang in
cpp | c\+\+)
    lang='cpp'
    ;;
py | python)
    lang='python'
    ;;
*)
    echo "Unsupported language: $lang"
    echo 'C++   : cpp, c++'
    echo 'Python: py, python'
    exit 5
    ;;
esac

if [[ -n "$file" ]]; then
    directory="${file%/*}"
    id_pattern='/([0-9]+)'

    if [[ "$file" =~ $id_pattern ]]; then
        problem_id=${BASH_REMATCH[1]}
        input_file="$directory/input/1.txt"
        output_file="$directory/output/1.txt"

        if [[ -n "$problem_id" ]] && [ ! -e "$input_file" ] || [ ! -e "$output_file" ]; then
            echo "Fetching test cases for $problem_id..."
            bash start "$problem_id" "$directory"
        fi
    fi
else
    output=false
fi

python3 src/python/test.py "$lang" "$directory" "$output"

if [[ -n "$file" ]]; then
    rm -rf "$directory/input"
    rm -rf "$directory/output"
fi
